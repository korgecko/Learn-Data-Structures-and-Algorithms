# 1. 현재 나이트의 위치를 입력받습니다. (예: a1, c2 등)
current_pos = input()

# 2. 입력된 위치를 행(row)과 열(column) 숫자로 변환합니다.
#    열: 'a'는 1, 'b'는 2, ... , 'h'는 8로 변환합니다.
#    ord() 함수는 문자를 컴퓨터가 인식하는 고유 숫자(아스키 코드)로 바꿔줍니다.
#    'c'의 숫자에서 'a'의 숫자를 빼면('c'가 'a'로부터 얼마나 떨어져 있는지) 2가 나옵니다.
#    여기에 1을 더해 1~8 범위의 숫자로 맞춰줍니다. (예: 'c' -> 3)
start_col = ord(current_pos[0]) - ord('a') + 1

#    행: 입력받은 문자를 숫자로 변환합니다. (예: '2' -> 2)
start_row = int(current_pos[1])

# 3. 나이트가 이동할 수 있는 8가지 방향을 정의합니다.
#    (행 변화량, 열 변화량) 형태로 구성됩니다.
steps = [
    (-2, -1), (-2, 1),  # 위로 2칸 이동 후, 좌/우로 1칸
    (2, -1), (2, 1),   # 아래로 2칸 이동 후, 좌/우로 1칸
    (-1, -2), (1, -2),  # 좌로 2칸 이동 후, 위/아래로 1칸
    (-1, 2), (1, 2)    # 우로 2칸 이동 후, 위/아래로 1칸
]

# 4. 이동 가능한 경우의 수를 셀 변수를 만듭니다.
possible_moves_count = 0

# 5. 8가지 모든 방향에 대해 이동 가능한지 확인합니다.
for move in steps:
    # 현재 위치에서 다음 위치를 계산합니다.
    next_row = start_row + move[0]
    next_col = start_col + move[1]

    # 다음 위치가 체스판(1~8 사이) 내에 있는지 확인합니다.
    if next_row >= 1 and next_row <= 8 and next_col >= 1 and next_col <= 8:
        # 체스판 내에 있다면, 이동 가능한 경우의 수를 1 증가시킵니다.
        possible_moves_count += 1

# 6. 최종적으로 계산된 경우의 수를 출력합니다.
print(possible_moves_count)
