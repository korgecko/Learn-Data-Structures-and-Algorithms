def solve():
    """
    두 배열 A, B의 원소를 최대 K번 바꿔치기하여 배열 A의 합을 최대로 만드는 문제를 해결하는 함수입니다.
    """
    # 1. 데이터 입력
    # N: 배열의 원소 개수, K: 최대 바꿔치기 횟수
    try:
        n, k = map(int, input().split())
        a = list(map(int, input().split()))
        b = list(map(int, input().split()))
    except ValueError:
        print("입력이 잘못되었습니다. 정수를 입력해주세요.")
        return

    # 2. 문제 해결을 위한 최적의 전략: 배열 정렬
    # A는 오름차순으로 정렬하여 가장 '작은' 원소부터 교체 대상으로 삼습니다.
    a.sort()
    # B는 내림차순으로 정렬하여 가장 '큰' 원소부터 A에 넣어줄 후보로 삼습니다.
    b.sort(reverse=True)

    # 3. 원소 교체 수행 (최대 K번)
    # K번의 기회를 모두 사용하거나, 더 이상 교체하는 것이 이득이 없을 때까지 반복합니다.
    for i in range(k):
        # A의 가장 작은 원소(a[i])가 B의 가장 큰 원소(b[i])보다 작을 때만 교체하는 것이 이득입니다.
        if a[i] < b[i]:
            # 두 원소를 서로 바꿔치기합니다. (Python의 스왑 기능)
            a[i], b[i] = b[i], a[i]
        else:
            # 만약 A의 원소가 B의 원소보다 크거나 같다면,
            # 그 뒤의 원소들은 볼 필요도 없이 교체하는 것이 손해입니다.
            # (왜냐하면 a는 점점 커지고, b는 점점 작아지기 때문입니다)
            # 따라서 더 이상의 비교는 무의미하므로 반복문을 즉시 탈출하여 효율을 높입니다.
            break

    # 4. 최종 결과 출력
    # 바꿔치기가 모두 끝난 배열 a의 모든 원소의 합을 계산하여 출력합니다.
    print(sum(a))

# 메인 실행 블록
if __name__ == "__main__":
    solve()
