# DFS로 (x, y) 위치에서 시작해, 상하좌우로 '연결된 0들'을 모두 1로 바꾸며 방문 처리한다.
# (새로운 0 무리의 시작점에서만 True를 반환하여, 연결 요소(덩어리) 개수를 하나 올릴 수 있게 함)
def dfs(x, y):
    # 1) 범위(바운더리) 검사: 격자 바깥이면 탐색 종료
    if x < 0 or x >= n or y < 0 or y >= m:
        return False

    # 2) 아직 방문하지 않은 '빈칸(0)'을 만났을 때만 확장
    if graph[x][y] == 0:
        # 방문 처리: 다시 오지 않도록 1로 바꿔둔다(=벽처럼 취급, 방문 표시 역할)
        graph[x][y] = 1

        # 3) 상/하/좌/우로 재귀 확장 (연결된 모든 0을 한 덩어리로 처리)
        dfs(x - 1, y)  # 위
        dfs(x + 1, y)  # 아래
        dfs(x, y - 1)  # 왼쪽
        dfs(x, y + 1)  # 오른쪽

        # 4) 이 호출이 '새 덩어리의 시작점'이었음을 알리기 위해 True 반환
        return True

    # 이 위치가 0이 아니면(=이미 방문했거나 원래 1이거나) 새 덩어리 시작이 아님
    return False


# -------------------- 입력 --------------------
# n: 행(row) 수, m: 열(column) 수
n, m = map(int, input().split())

# 2차원 리스트로 격자(그래프) 입력
# 각 줄이 공백 없이 0과 1로만 들어오므로, 문자열의 각 문자(char)를 정수로 변환해 리스트로 만듦
# 예: "01" -> [0, 1]
graph = []
for _ in range(n):
    line = input().strip()          # 줄 끝 개행 제거
    graph.append(list(map(int, line)))

# -------------------- 전체 순회 --------------------
# 모든 좌표 (i, j)를 돌며, '새로운 0 무리'의 시작점을 찾을 때마다 dfs가 True를 돌려줌
result = 0
for i in range(n):
    for j in range(m):
        if dfs(i, j):               # True면 새 연결 요소 하나 발견
            result += 1

print(result)

// input 입력방법
// 2 3
// 010
// 101
// 이렇게 행렬식 입력



